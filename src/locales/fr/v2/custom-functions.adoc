[[customfunctionssongstructure]]
== Custom Functions, Song Structure
:nofooter:

The song structure is the song's organization over time: how to create meaningful sections and transitions for the flow of your music. In this chapter, you'll create your own functions: custom functions, to structure your songs!

[[asongsstructure]]
=== La structure d'une chanson
:nofooter:

Une chanson peut être divisée en *parties ou « sections »*. Une section est composée de plusieurs mesures (unités de temps musicales), elle exprime une idée ou un sentiment. Habituellement, les musiciens essaient d'ajouter un certain contraste entre les différentes sections. Les intros, les couplets, les refrains et les outros sont des exemples de sections de morceaux.

Une *forme* ou structure de chanson classique est la forme ABA. A et B sont deux parties distinctes, par exemple le refrain et le couplet. La partie B ajoute de la variété à la chanson, tandis que la reprise de la partie A fait appel à la familiarité. Le code ci-dessous crée une structure de morceau de type ABA. La partie B comprend des sons contrastants par rapport à la partie A : une basse plus lente et plus forte et une percussion supplémentaire :

[[imediau2sections_052016png]]
.Une forme ternaire ABA dans le studio de travail audionumérique (DAW) de EarSketch
[caption="Figure 9.2: "]
image::../media/U2/sections_052016.png[Alt Text]

[role="curriculum-python"]
[source,python]
----
# Forme A-B-A : Une chanson composée de parties A et B

# Paramétrage
from earsketch import *
setTempo(120)

# Musique

# Création d'une partie A

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 1, 5)  # mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 1, 5)  # percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 1, 5)  # ligne de basse
setEffect(3, VOLUME, GAIN, -20, 1, 0, 5)  # augmentation du volume de la ligne de basse

# Création d'une partie B à quatre mesures entre la mesure 5 et 9

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_1, 1, 5, 9)  # variation de la mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_5, 2, 5, 9)  # variation des percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_3, 3, 5, 9)  # basse de contraste : plus lente et plus forte
setEffect(3, VOLUME, GAIN, 5, 5, 5, 9)  # augmentation du volume de la basse
fitMedia(RD_WORLD_PERCUSSION_SEEDSRATTLE_1, 4, 5, 9)  # ajout d'un nouvel élément de percussion

# Reprise de la partie A à la mesure 9

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 9, 13)  # mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 9, 13)  # percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 9, 13)  # ligne de basse
setEffect(3, VOLUME, GAIN, 0, 9, -20, 13)  # augmentation du volume de la ligne de basse
----


[role="curriculum-javascript"]
[source,javascript]
----
// Forme A-B-A : Une chanson composée de parties A et B

// Paramétrage
setTempo(120);

// Musique

// Création d'une partie A

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 1, 5); // mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 1, 5); // percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 1, 5); // ligne de basse
setEffect(3, VOLUME, GAIN, -20, 1, 0, 5); // augmentation du volume de la ligne de basse

// Création d'une partie B à quatre mesures entre les mesures 5 et 9

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_1, 1, 5, 9); // variation de la mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_5, 2, 5, 9); // variation des percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_3, 3, 5, 9); // basse de contraste : plus lente et plus forte
setEffect(3, VOLUME, GAIN, 5, 5, 5, 9); // augmentation du volume de la basse
fitMedia(RD_WORLD_PERCUSSION_SEEDSRATTLE_1, 4, 5, 9); // ajout d'un nouvel élément de percussion

// Reprise de la partie A à la mesure 9

fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 9, 13); // mélodie principale
fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 9, 13); // percussions
fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 9, 13); // ligne de basse
setEffect(3, VOLUME, GAIN, -20, 9, 0, 13); // augmentation du volume de la ligne de basse
----

.ENTRAÎNEZ-VOUS
****
Sélectionnez d'abord une chanson que vous aimez. Écoutez-la et tentez de repérer les différentes sections. Pouvez-vous distinguer le moment où les musiciens changent de partie ? Combien de refrains ou de couplets pouvez-vous entendre ? Quels types de contrastes observez-vous ? Partagez votre chanson avec votre voisin.e.
****

Gardez à l'esprit qu'une phrase musicale semble plus naturelle lorsque les clips sont organisés en groupes de 2, 4, 8, 16, etc. Par conséquent, vos parties devraient de préférence avoir une longueur de 2, 4, 8 ou 16 mesures.

[[creatingyourcustomfunctions]]
=== Create your custom functions

Dans l'exemple précédent avec la chanson de forme ABA, le code est long et se répète pour la deuxième partie A. Cependant, il y a un moyen d'être plus efficace, grâce aux *fonctions personnalisées* ! Nous allons définir une fonction qui représentera la partie A, puis nous l'appelerons à deux reprises.  

La différence avec les fonctions que vous avez précédemment utilisées comme `fitMedia()` est que vous devrez définir votre fonction personnalisée, tandis que la fonction `fitMedia()` est déjà prédéfinie. Voici comment vous définirez la partie A :

[role="curriculum-python"]
[source,python]
----
def sectionA():
    # Ici, écrivez vos instructions. Voici le corps des fonctions :
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 1, 5)  # mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 1, 5)  # percussions
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 1, 5)  # ligne de basse
    setEffect(3, VOLUME, GAIN, -20, 1, 0, 5)  # augmentation du volume de la ligne de basse
    # Cette portion de code est indentée. Lorsque vous écrivez le reste de votre script, assurez-vous d'arrêter l'indentation.
----

[role="curriculum-javascript"]
[source,javascript]
----
function sectionA() {
    // Ici, écrivez vos instructions. Voici le corps des fonctions :
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, 1, 5); // mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, 1, 5); // percussions
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, 1, 5); // ligne de basse
    setEffect(3, VOLUME, GAIN, -20, 1, 0, 5); // augmentation du volume de la ligne de basse
    // Cette portion de code est indentée. Lorsque vous écrivez le reste de votre script, assurez-vous d'arrêter l'indentation.
}

----

. Ici, nous avons choisi sectionA() comme nom pour notre fonction, mais vous pouvez choisir le nom que vous souhaitez. Essayez de nommer votre fonction de manière descriptive afin que votre code soit plus facile à lire.
. Les instructions correspondent au *corps* de la fonction. Elles sont indentées.

.ENTRAÎNEZ-VOUS
****
Collez ce code dans un nouveau script et exécutez-le. Vous remarquerez que votre DAW n'affiche rien. 
C'est parce que vous devez *appeler* une fonction pour l'utiliser.  
Pour appeler votre fonction, ajoutez la ligne `sectionA()` non indentée après la définition de votre fonction. Lorsque vous exécuterez le code, vous devriez voir la partie A dans votre DAW.
****

Nous voulons maintenant ajouter la partie A de la mesure 9 à 13. Cependant, lorsque la fonction sectionA() est appelée, nous remarquons que les sons sont placés des mesures 1 à 5. Pour remédier à ce problème, nous allons créer des *paramètres* pour notre fonction.

.ENTRAÎNEZ-VOUS
****
In your current script, 
1. ajoutez les paramètres `startMeasure` et `endMeasure` séparés par une virgule entre les parenthèses de la fonction sectionA() dans sa définition. (`sectionA(startMeasure,endMeasure)`).
2. Dans le corps de la fonction, remplacez les mesures de début (1) et de fin (5) par `startMeasure` et `endMeasure` respectivement.
3. Lorsque vous appelez votre fonction, ajoutez les paramètres `1` et `5` entre les parenthèses. Exécutez le code pour vous assurer qu'il n'y a aucune erreur.
4. Ajoutez un deuxième appel de fonction, mais cette fois-ci, avec les paramètres `9` et `13`. Exécutez le code pour vous assurer qu'il n'y a aucune erreur.
5. Définissez une fonction pour la partie B, en suivant le même processus, et appelez la partie B des mesures 5 à 9 et des mesures 13 à 17.
****

Voici à quoi devrait ressembler votre code :

[role="curriculum-python"]
[source,python]
----
# Forme A-B-A-B et fonctions personnalisées : Une chanson composée de parties A et B à l'aide des fonctions personnalisées

# Paramétrage
from earsketch import *
setTempo(120)

# Musique

# Création d'une fonction pour la partie A
def sectionA(startMeasure, endMeasure):
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, startMeasure, endMeasure)  # mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, startMeasure, endMeasure)  # percussions
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, startMeasure, endMeasure)  # ligne de basse
    setEffect(3, VOLUME, GAIN, -20, startMeasure, 0, endMeasure)  # augmentation du volume de la ligne de basse

# Création d'une fonction pour la partie B
def sectionB(startMeasure, endMeasure):
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_1, 1, startMeasure, endMeasure)  # variation de la mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_5, 2, startMeasure, endMeasure)  # variation des percussions
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_3, 3, startMeasure, endMeasure)  # basse de contraste : plus lente et plus forte
    setEffect(3, VOLUME, GAIN, 5, startMeasure, 5, endMeasure)  # augmentation du volume de la basse
    fitMedia(RD_WORLD_PERCUSSION_SEEDSRATTLE_1, 4, startMeasure, endMeasure)  # ajout d'un élément de percussion

# Appels de fonction
sectionA(1, 5)
sectionB(5, 9)
sectionA(9, 13)
sectionB(13, 17)
----

[role="curriculum-javascript"]
[source,javascript]
----

// Forme A-B-A-B et fonctions personnalisées : Une chanson composée de parties A et B à l'aide des fonctions personnalisées

// Paramétrage
setTempo(120);

// Musique

// Création d'une fonction pour la partie A
function sectionA(startMeasure, endMeasure) {
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_7, 1, startMeasure, endMeasure); // mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_24, 2, startMeasure, endMeasure); // percusisons
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_2, 3, startMeasure, endMeasure); // ligne de basse
    setEffect(3, VOLUME, GAIN, -20, startMeasure, 0, endMeasure); // augmentation du volume de la ligne de basse
}

// Création d'une fonction pour la partie B
function sectionB(startMeasure, endMeasure) {
    fitMedia(RD_WORLD_PERCUSSION_KALIMBA_PIANO_1, 1, startMeasure, endMeasure); // variation de la mélodie principale
    fitMedia(RD_WORLD_PERCUSSION_DRUMPART_5, 2, startMeasure, endMeasure); // variation des percussions
    fitMedia(RD_UK_HOUSE__EVOLVEPAD_3, 3, startMeasure, endMeasure); // basse de contraste : plus lente et plus forte
    setEffect(3, VOLUME, GAIN, 5, startMeasure, 5, endMeasure); // augmentation du volume de la basse
    fitMedia(RD_WORLD_PERCUSSION_SEEDSRATTLE_1, 4, startMeasure, endMeasure); // ajout d'un élément de percussion
}

// Appels de fonction
sectionA(1, 5);
sectionB(5, 9);
sectionA(9, 13);
sectionB(13, 17);
----


//The following video will be cut in 2 with the beginning going to chapter 7.1, and the end to this chpater. For more info see https://docs.google.com/spreadsheets/d/114pWGd27OkNC37ZRCZDIvoNPuwGLcO8KM5Z_sTjpn0M/edit#gid=302140020//


[role="curriculum-python curriculum-mp4"]
[[video93py]]
video::./videoMedia/009-03-CustomFunctions-PY.mp4[]

[role="curriculum-javascript curriculum-mp4"]
[[video93js]]
video::./videoMedia/009-03-CustomFunctions-JS.mp4[]


[[transitionstrategies]]
=== Stratégies de transition

Maintenant que vous savez comment créer des fonctions personnalisées pour structurer votre chanson, nous allons examiner la notion de transitions. Les *transitions* aident à passer en douceur d'une partie à l'autre. Celles-ci permettent de relier les versets et le refrain, de faire une montée jusqu'à un drop, de mixer des pistes (DJing) ou de faire un changement de tonalité. Le but d'une transition est d'attirer l'attention de l'auditeur et de leur faire savoir qu'un changement est sur le point de se produire. 

Voici quelques stratégies populaires pour créer des transitions musicales :

. *Cymbale à main ou « Crash Cymbal »* : placement d'une cymbale à main sur le premier beat ou rythme d'une nouvelle partie. Voyez l'exemple https://www.youtube.com/watch?v=RssWT0Wem2w&t=0m55s[suivant^].
. *Roulement de batterie ou « Drum Fill »* : une variation rythmique pour combler le vide avant une nouvelle partie. Voyez ces https://www.youtube.com/watch?v=YMskGG39Y0Y[exemples^] de remplissage de batterie.
. *Pistes en sourdine ou «Track Dropouts »* : Ajouts de drops de manière temporaire dans les pistes (une piste devient muette) pour créer des pauses. Écoutez https://www.youtube.com/watch?v=PxIgHSOLO_Q[Love de Imagine Dragons], à 1'16 par exemple.
. *Variation de mélodie* : Introduction d'une variation des accords, de la ligne de basse ou de la mélodie avant la nouvelle partie. Il arrive souvent qu'un dossier dans la bibliothèque de sons EarSketch contienne des variations similaires. 
. *Riser* (lire "raïseur") : Une note ou un bruit qui augmente en hauteur. C'est très courant en musique de danse électronique ou dance (EDM) et crée l'anticipation d'une perte de niveau sonore. Vous pouvez utiliser le terme de recherche « riser » dans le navigateur de sons. Une cymbale à main inversée peut être utilisée comme riser, comme YG_EDM_REVERSE_CRASH_1. Voici un exemple de riser dans https://www.youtube.com/watch?v=1KGsAozrCnA&t=31m30s[un set techno de Carl Cox^].
. *Roulement de caisse claire ou « Snare Roll »* : Une séquence de coups de caisse claire répétés, avec une densité, hauteur ou amplitude croissante. Vous pouvez utiliser un clip comme RD_FUTURE_DUBSTEP_FILL_1 ou HOUSE_BREAK_FILL_003, ou `makeBeat()`. Voyez ici un https://www.youtube.com/watch?v=c3HLuTAsbFE[exemple^].
. *Boucle ou « Looping »* : Répétition d'un court segment de mélodie avant une nouvelle partie. Voyez ici un https://www.youtube.com/watch?v=AQg4wnbBjiQ[exemple^] de boucle en DJing.
. *Fondu enchaîné ou « Crossfading »* : Diminution du volume d'une partie en augmentant le volume de la partie suivante. 
. *Anacrouse ou « Anacrusis »* : Lorsque la mélodie de la nouvelle partie commence quelques beats plus tôt.

.ENTRAÎNEZ-VOUS
****
Dans la liste de transitions possibles, sélectionnez-en deux et essayez de voir comment vous pouvez les implémenter en utilisant un code. Vous pouvez travailler en équipe. Une fois que vous y avez réfléchi, jetez un coup d'œil aux exemples ci-dessous.
****
La transition doit être placée 1 ou 2 mesures avant la nouvelle partie. Vous pouvez utiliser plusieurs techniques de transition à la fois. 

Remplissages de batterie :

[role="curriculum-python"]
[source,python]
----
# Techniques de transition - Remplissage de batterie : Transition entre parties à l'aide d'un remplissage de batterie

# Paramétrage
from earsketch import *
setTempo(130)

# Musique
leadGuitar1 = RD_ROCK_POPLEADSTRUM_GUITAR_4
leadGuitar2 = RD_ROCK_POPLEADSTRUM_GUITAR_9
bass1 = RD_ROCK_POPELECTRICBASS_8
bass2 = RD_ROCK_POPELECTRICBASS_25
drums1 = RD_ROCK_POPRHYTHM_DRUM_PART_10
drums2 = RD_ROCK_POPRHYTHM_MAINDRUMS_1
drumFill = RD_ROCK_POPRHYTHM_FILL_4

# Partie 1
fitMedia(leadGuitar1, 1, 1, 8)
fitMedia(bass1, 2, 1, 8)
fitMedia(drums1, 3, 1, 8)

# Remplissage de batterie
fitMedia(drumFill, 3, 8, 9)

# Partie 2
fitMedia(leadGuitar2, 1, 9, 17)
fitMedia(bass2, 2, 9, 17)
fitMedia(drums2, 3, 9, 17)
----

[role="curriculum-javascript"]
[source,javascript]
----
// Techniques de transition - Remplissage de batterie : Transition entre parties à l'aide d'un remplissage de batterie

// Paramétrage
setTempo(130);

// Musique
var leadGuitar1 = RD_ROCK_POPLEADSTRUM_GUITAR_4;
var leadGuitar2 = RD_ROCK_POPLEADSTRUM_GUITAR_9;
var bass1 = RD_ROCK_POPELECTRICBASS_8;
var bass2 = RD_ROCK_POPELECTRICBASS_25;
var drums1 = RD_ROCK_POPRHYTHM_DRUM_PART_10;
var drums2 = RD_ROCK_POPRHYTHM_MAINDRUMS_1;
var drumFill = RD_ROCK_POPRHYTHM_FILL_4;

// Partie 1
fitMedia(leadGuitar1, 1, 1, 8);
fitMedia(bass1, 2, 1, 8);
fitMedia(drums1, 3, 1, 8);

// Remplissage de batterie
fitMedia(drumFill, 3, 8, 9);

// Partie 2
fitMedia(leadGuitar2, 1, 9, 17);
fitMedia(bass2, 2, 9, 17);
fitMedia(drums2, 3, 9, 17);
----

La technique de pistes en sourdine (track dropout) nécessite la modification de quelques appels de fonction `fitMedia()`. Voyez l'exemple illustré ci-dessous.

[role="curriculum-python"]
[source,python]
----
# Techniques de transition - Pertes de niveau audio de piste : Transition entre des parties avec pertes de niveau audio sélectives

# Paramétrage
from earsketch import *
setTempo(120)

# Musique
introLead = TECHNO_ACIDBASS_002
mainLead1 = TECHNO_ACIDBASS_003
mainLead2 = TECHNO_ACIDBASS_005
auxDrums1 = TECHNO_LOOP_PART_025
auxDrums2 = TECHNO_LOOP_PART_030
mainDrums = TECHNO_MAINLOOP_019
bass = TECHNO_SUBBASS_002

# Partie 1
fitMedia(introLead, 1, 1, 5)
fitMedia(mainLead1, 1, 5, 9)
fitMedia(auxDrums1, 2, 3, 5)
fitMedia(auxDrums2, 2, 5, 8)  # Sortie des percussions
fitMedia(mainDrums, 3, 5, 8)

# Partie 2
fitMedia(mainLead2, 1, 9, 17)
fitMedia(auxDrums2, 2, 9, 17)  # Entrée des percussions à nouveau
fitMedia(mainDrums, 3, 9, 17)
fitMedia(bass, 4, 9, 17)
----

[role="curriculum-javascript"]
[source,javascript]
----
// Techniques de transition - Pertes de niveau audio de piste : Transition entre des parties avec pertes de niveau audio sélectives

// Paramétrage
setTempo(120);

// Musique
var introLead = TECHNO_ACIDBASS_002;
var mainLead1 = TECHNO_ACIDBASS_003;
var mainLead2 = TECHNO_ACIDBASS_005;
var auxDrums1 = TECHNO_LOOP_PART_025;
var auxDrums2 = TECHNO_LOOP_PART_030;
var mainDrums = TECHNO_MAINLOOP_019;
var bass = TECHNO_SUBBASS_002;

// Partie 1
fitMedia(introLead, 1, 1, 5);
fitMedia(mainLead1, 1, 5, 9);
fitMedia(auxDrums1, 2, 3, 5);
fitMedia(auxDrums2, 2, 5, 8); // Sortie des percussions
fitMedia(mainDrums, 3, 5, 8);

// Partie 2
fitMedia(mainLead2, 1, 9, 17);
fitMedia(auxDrums2, 2, 9, 17); // Entrée des percussions à nouveau
fitMedia(mainDrums, 3, 9, 17);
fitMedia(bass, 4, 9, 17);
----

L'exemple suivant utilise plusieurs risers et une cymbale à main pendant la transition.

[role="curriculum-python"]
[source,python]
----
# Techniques de transition - Risers : Transition entre parties à l'aide de risers et d'une cymbale à main

# Paramétrage
from earsketch import *
setTempo(128)

# Musique
synthRise = YG_EDM_SYNTH_RISE_1
airRise = RD_EDM_SFX_RISER_AIR_1
lead1 = YG_EDM_LEAD_1
lead2 = YG_EDM_LEAD_2
kick1 = YG_EDM_KICK_LIGHT_1
kick2 = ELECTRO_DRUM_MAIN_LOOPPART_001
snare = ELECTRO_DRUM_MAIN_LOOPPART_003
crash = Y50_CRASH_2
reverseFX = YG_EDM_REVERSE_FX_1

# Partie 1
fitMedia(lead1, 1, 1, 17)
fitMedia(kick1, 2, 9, 17)

# Transition
fitMedia(reverseFX, 3, 16, 17)
fitMedia(synthRise, 4, 13, 17)
fitMedia(airRise, 5, 13, 17)
fitMedia(crash, 6, 17, 19)

# Partie 2
fitMedia(lead2, 1, 17, 33)
fitMedia(kick2, 7, 25, 33)
fitMedia(snare, 8, 29, 33)

# Effets
setEffect(1, VOLUME, GAIN, 0, 16, 1, 17)  # Réglage des volumes pour une meilleure harmonisation
setEffect(4, VOLUME, GAIN, -10)
setEffect(7, VOLUME, GAIN, -20)
setEffect(8, VOLUME, GAIN, -20)
----

[role="curriculum-javascript"]
[source,javascript]
----
// Techniques de transition - Risers : Transition entre parties à l'aide de risers et d'une cymbale à main

// Paramétrage
setTempo(128);

// Musique
var synthRise = YG_EDM_SYNTH_RISE_1;
var airRise = RD_EDM_SFX_RISER_AIR_1;
var lead1 = YG_EDM_LEAD_1;
var lead2 = YG_EDM_LEAD_2;
var kick1 = YG_EDM_KICK_LIGHT_1;
var kick2 = ELECTRO_DRUM_MAIN_LOOPPART_001;
var snare = ELECTRO_DRUM_MAIN_LOOPPART_003;
var crash = Y50_CRASH_2;
var reverseFX = YG_EDM_REVERSE_FX_1;

// Partie 1
fitMedia(lead1, 1, 1, 17);
fitMedia(kick1, 2, 9, 17);

// Transition
fitMedia(reverseFX, 3, 16, 17);
fitMedia(synthRise, 4, 13, 17);
fitMedia(airRise, 5, 13, 17);
fitMedia(crash, 6, 17, 19);

// Partie 2
fitMedia(lead2, 1, 17, 33);
fitMedia(kick2, 7, 25, 33);
fitMedia(snare, 8, 29, 33);

// Effets
setEffect(1, VOLUME, GAIN, 0, 16, 1, 17); // Réglage des volumes pour une meilleure harmonisation
setEffect(4, VOLUME, GAIN, -10);
setEffect(7, VOLUME, GAIN, -20);
setEffect(8, VOLUME, GAIN, -20);
----

[[yourfullsong]]
=== Votre chanson complète

En programmation, nous pouvons créer des *abstractions*, soit le fait de regrouper des idées pour former un concept unique. De même, en musique, nous regroupons les idées musicales en sections. Les fonctions sont un type d'abstraction utilisé en informatique. Elles intègrent plusieurs instructions dans un seul outil pour être facilement appelées. Les abstractions peuvent ainsi rendre la forme d'un programme plus claire.

.ENTRAÎNEZ-VOUS
****
À présent, tentez de créer une chanson complète en utilisant tous les outils que vous avez découverts dans EarSketch ! Retrouvez ci-dessous une suggestion de méthodologie de travail, mais que vous pouvez adapter comme vous le souhaitez :

. Choisissez un thème pour votre chanson. Pensez au type de sons, d'instruments ou de paroles qui véhiculeront au mieux votre message.
. Then select a simple structure. 
. Et maintenant, vous pouvez enfin commencer à coder ! Commencez par sélectionner les sons et mettez-les dans des fonctions `fitMedia()`.
. Utilisez `makeBeat()` pour ajouter des percussions.
. Vous pouvez aussi ajouter vos propres sons.
. Utilisez des boucles pour réduire les répétitions dans votre code.
. Utilisez des fonctions personnalisées pour définir vos parties et créez la structure de votre chanson.
. Ajoutez une ou deux transitions.
. Ajoutez des effets avec setEffect().
. Ajoutez une ou plusieurs instructions conditionnelles.
. Assurez-vous d'utiliser des variables pour stocker des informations comme les noms des clips de sons.
. Assurez-vous d'utiliser des commentaires pour expliquer votre processus.
. N'oubliez pas d'exécuter votre code et d'écouter votre chanson régulièrement. Ceci vous aidera à la modifier jusqu'à ce que vous en soyez satisfait.
. Choisissez le titre de votre chanson.
****

Voici un exemple de chanson complète :

[role="curriculum-python"]
[source,python]
----
# Total Atlanta Song of Summer : création d'une chanson complète avec des abstractions

from earsketch import *
setTempo(110)

# Variables de sons
melody1 = EIGHT_BIT_ATARI_BASSLINE_005
melody2 = DUBSTEP_LEAD_018
melody3 = DUBSTEP_LEAD_017
melody4 = DUBSTEP_LEAD_013
bass1 = HIPHOP_BASSSUB_001
bass2 = RD_TRAP_BASSDROPS_2
brass1 = Y30_BRASS_4
shout = CIARA_SET_TALK_ADLIB_AH_4
piano = YG_RNB_PIANO_4
kick = OS_KICK02
hihat = OS_CLOSEDHAT03

# DÉFINITIONS DE FONCTION

# Ajout de percussions :
def addingDrums(start, end, pattern):
    # tout d'abord, nous devons créer des chaînes de caractères de beat, en fonction du motif du paramètre :
    if pattern == "heavy":
        beatStringKick = "0---0---0---00--"
        beatStringHihat = "-----000----0-00"
    elif pattern == "light":
        beatStringKick = "0-------0---0---"
        beatStringHihat = "--0----0---0---"
    # ensuite, nous pouvons créer le beat
    # sur la piste 3 pour la grosse caisse et sur la piste 4 pour le charleston,
    # de la mesure de début à la mesure de fin :
    for measure in range(start, end):
        # ici, nous allons placer notre beat sur "measure",
        # qui sera d'abord égal à "start",
        # qui est un paramètre de la fonction
        makeBeat(kick, 3, measure, beatStringKick)
        makeBeat(hihat, 4, measure, beatStringHihat)

# Intro :
def intro(start, end):
    fitMedia(melody1, 1, start, start + 1)
    fitMedia(melody1, 1, start + 2, start + 3)
    fitMedia(bass1, 2, start, start + 3)
    # transition :
    fitMedia(bass2, 2, start + 3, end)
    fitMedia(shout, 3, start + 3.75, end)

# SectionA :
def sectionA(start, end):
    fitMedia(melody2, 1, start, end)
    fitMedia(brass1, 2, start, end)
    setEffect(2, VOLUME, GAIN, -20, start, -10, end)
    addingDrums(start, end, "heavy")
    # Modulation de hauteur pour la transition :
    setEffect(1, BANDPASS, BANDPASS_FREQ, 200, end - 2, 1000, end)

# SectionB :
def sectionB(start, end):
    fitMedia(melody3, 1, start, start + 2)
    fitMedia(melody4, 1, start + 2, end)
    fitMedia(piano, 2, start, end)
    addingDrums(start, end, "light")

# APPELS DE FONCTION
intro(1, 5)
sectionA(5, 9)
sectionB(9, 13)
sectionA(13, 17)
sectionB(17, 21)

# Fondu de fermeture :
for track in range(1, 5):
    setEffect(track, VOLUME, GAIN, 0, 19, -60, 21)
# Réduction de volume de la grosse caisse et du charleston :
setEffect(4, VOLUME, GAIN, -15)
setEffect(3, VOLUME, GAIN, -10)
----
[role="curriculum-javascript"]
[source,javascript]
----
// Total Atlanta Song of Summer : création d'une chanson complète avec des abstractions

setTempo(110);

// Variables de sons
var melody1 = EIGHT_BIT_ATARI_BASSLINE_005;
var melody2 = DUBSTEP_LEAD_018;
var melody3 = DUBSTEP_LEAD_017;
var melody4 = DUBSTEP_LEAD_013;
var bass1 = HIPHOP_BASSSUB_001;
var bass2 = RD_TRAP_BASSDROPS_2;
var brass1 = Y30_BRASS_4;
var shout = CIARA_SET_TALK_ADLIB_AH_4;
var piano = YG_RNB_PIANO_4;
var kick = OS_KICK02;
var hihat = OS_CLOSEDHAT03;

// DÉFINITIONS DE FONCTION

// Ajout de percussions :
function addingDrums(start, end, pattern) {
    // tout d'abord, nous devons créer des chaînes de caractères de beat, en fonction du motif du paramètre :
    if (pattern == "heavy") {
        var beatStringKick = "0---0---0---00--";
        var beatStringHihat = "-----000----0-00";
    } else if (pattern == "light") {
        beatStringKick = "0-------0---0---";
        beatStringHihat = "--0----0---0---";
    }
    // ensuite, nous pouvons créer le beat,
    // sur la piste 3 pour la grosse caisse et sur la piste 4 pour le charleston,
    // de la mesure de début à la mesure de fin :
    for (var measure = start; measure < end; measure++) {
    // ici, nous allons placer notre beat sur "measure",
    // qui sera d'abord égal à "start",
    // qui est un paramètre de la fonction
        makeBeat(kick, 3, measure, beatStringKick);
        makeBeat(hihat, 4, measure, beatStringHihat);
    }
}

// Intro :
function intro(start, end) {
    fitMedia(melody1, 1, start, start + 1);
    fitMedia(melody1, 1, start + 2, start + 3);
    fitMedia(bass1, 2, start, start + 3);
    // transition :
    fitMedia(bass2, 2, start + 3, end);
    fitMedia(shout, 3, start + 3.75, end);
}
// SectionA :
function sectionA(start, end) {
    fitMedia(melody2, 1, start, end);
    fitMedia(brass1, 2, start, end);
    setEffect(2, VOLUME, GAIN, -20, start, -10, end);
    addingDrums(start, end, "heavy");
    // Modulation de hauteur pour la transition :
    setEffect(1, BANDPASS, BANDPASS_FREQ, 200, end - 2, 1000, end);
}

// SectionB :
function sectionB(start, end) {
    fitMedia(melody3, 1, start, start + 2);
    fitMedia(melody4, 1, start + 2, end);
    fitMedia(piano, 2, start, end);
    addingDrums(start, end, "light");
}

// APPELS DE FONCTION
intro(1, 5);
sectionA(5, 9);
sectionB(9, 13);
sectionA(13, 17);
sectionB(17, 21);

// Fondu de fermeture :
for (var track = 1; track < 5; track++) {
    setEffect(track, VOLUME, GAIN, 0, 19, -60, 21);
}

// Réduction de volume sur la grosse caisse et le charleston :
setEffect(4, VOLUME, GAIN, -15);
setEffect(3, VOLUME, GAIN, -10);
----

Dans cet exemple, nous avons utilisé une boucle « for » à l'intérieur d'une fonction personnalisée ! Nous avons utilisé des paramètres de la fonction (`start` et `end`) à l'intérieur de la boucle « for ».


[[chapter7summary]]
=== Résumé du chapitre 7

* Les *sections* sont des parties musicales composées de plusieurs mesures. Chacune exprime une idée ou un sentiment.
* Les *transitions* sont des passages de musique utilisés pour relier des parties musicales consécutives.
* On désigne par *forme* la structure et la variété que l'on trouve dans une chanson. Une forme musicale typique est A-B-A.
* Les *fonctions personnalisées* sont des fonctions uniques écrites par le programmeur pour accomplir une tâche spécifique. Vous devez créer une fonction personnalisée pour pouvoir l'appeler. Il est possible de créer autant de paramètres que vous voulez.
* Une *abstraction* est un regroupement d'idées pour former un concept unique, souvent moins complexe. Les fonctions sont un exemple d'abstraction.


[[chapter-questions]]
=== Questions

[question]
--
Parmi les propositions suivantes, laquelle N'EST PAS un exemple de section musicale ?
[answers]
* Les percussions
* L'intro
* Le couplet
* Le refrain
--

[question]
--
Qu'est-ce qu'une abstraction ?
[answers]
* Un regroupement d'idées pour former un concept unique
* Une variété de sons à travers les parties
* Des parties d'une chanson qui sont liées, mais sont également distinctes les unes des autres
* Une instruction qui renvoie une valeur à l'appel de la fonction
--

[role="curriculum-python"]
[question]
--
Parmi les options suivantes, laquelle définit correctement la fonction `myFunction()` avec les paramètres `startMeasure` et `endMeasure` ?
[answers]
* `def myFunction(startMeasure, endMeasure):`
* `def myFunction():`
* `myFunction(startMeasure, endMeasure):`
* `myFunction(2, 5)`
--

[role="curriculum-javascript"]
[question]
--
Parmi les options suivantes, laquelle définit correctement la fonction `myFunction()` avec les paramètres `startMeasure` et `endMeasure` ?
[answers]
* `function myFunction(startMeasure, endMeasure) {}`
* `function myFunction() {}`
* `myFunction(startMeasure, endMeasure){}`
* `myFunction(2, 5)`
--

[question]
--
Parmi les propositions suivantes, laquelle N'EST PAS un exemple de transition ?
[answers]
* La cohérence de la mélodie
* La cymbale à main
* Riser
* Les pistes en sourdine
--
